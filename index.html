<!-- 
==========================================================
  MINI TERRARIA-STYLE SANDBOX GAME - FULL EXPLANATION
==========================================================

WHAT THIS FILE DOES:
- Creates a 2D sandbox game in the browser, playable on a canvas.
- Procedural terrain is generated using a seed (optional) for reproducibility.
- Smooth terrain: grass → dirt → stone → bedrock.
- Player with 4-side collision, gravity, and camera scrolling.
- Click to place/remove blocks.
- Save and load your world and inventory as JSON files.
- Menu screen: choose map width, height, and seed before starting.
- Loading screen: progress bar generates world column by column to avoid browser freeze.
- Inventory: 3 block types (dirt=1, grass=2, stone=3) with infinite default stacks.
- Number keys 1-3 select the block type.
- Player input: WASD or arrow keys (W/ArrowUp = jump).

HOW IT WORKS:
1. Menu Screen:
   - Enter map width, height, optional seed.
   - Start button generates the world and shows loading progress.
   - Load button lets you import a previously saved JSON file.
2. World Generation:
   - The world is represented as a 2D array world[y][x].
   - Each column is generated one at a time to avoid freezing the browser.
   - Bedrock at bottom, sky at top, grass layer on top of dirt/stone.
   - Seeded PRNG ensures reproducible terrain.
3. Game Loop:
   - Player movement and gravity handled each frame.
   - Collision detection prevents walking through blocks.
   - Camera follows the player.
4. Interactions:
   - Click on empty blocks to place a block of the currently selected type.
   - Click on existing blocks (except bedrock) to remove them and add to inventory.
   - Save button exports a JSON file with world, player, and inventory.
   - Load via file input restores saved data.
5. Notes:
   - TILE_SIZE can be adjusted for larger/smaller tiles.
   - Map sizes too large may still lag the browser.
   - Seed input can be left blank for random worlds.
   - You can expand: caves, ores, biomes, multiple block types, etc.

==========================================================
-->

<!DOCTYPE html>
<html>
<head>
  <title>Sandbox Game with Seed & Save</title>
  <style>
    body { margin:0; font-family:sans-serif; overflow:hidden; }
    canvas { background:#87CEEB; display:block; margin:0 auto; }
    #menu, #loading {
      position:absolute; top:0; left:0; width:100%; height:100%;
      display:flex; justify-content:center; align-items:center;
      background:rgba(0,0,0,0.8); color:white; flex-direction:column;
      z-index:100;
    }
    input { margin:5px; padding:5px; }
    #loadingBarContainer {
      width:400px; height:20px; border:2px solid white; margin-top:20px;
    }
    #loadingBar { width:0%; height:100%; background:limegreen; }
    button { padding:5px 10px; margin:5px; cursor:pointer; }
  </style>
</head>
<body>

<!-- MENU SCREEN -->
<div id="menu">
  <h1>Sandbox Game</h1>
  <label>Map Width: <input type="number" id="mapWidth" value="100" min="20" max="500"></label>
  <label>Map Height: <input type="number" id="mapHeight" value="256" min="50" max="512"></label>
  <label>Seed (optional): <input type="text" id="seedInput" placeholder="random"></label>
  <div>
    <button id="startBtn">Start Game</button>
    <button id="loadBtn">Load Save</button>
    <input type="file" id="fileInput" style="display:none">
  </div>
</div>

<!-- LOADING SCREEN -->
<div id="loading" style="display:none">
  <h2>Loading World...</h2>
  <div id="loadingBarContainer"><div id="loadingBar"></div></div>
</div>

<canvas id="game" width="800" height="600"></canvas>

<script>
// -------------------- CANVAS --------------------
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

// -------------------- MENU ELEMENTS --------------------
const menu = document.getElementById("menu");
const loadingScreen = document.getElementById("loading");
const loadingBar = document.getElementById("loadingBar");
const mapWidthInput = document.getElementById("mapWidth");
const mapHeightInput = document.getElementById("mapHeight");
const seedInput = document.getElementById("seedInput");
const startBtn = document.getElementById("startBtn");
const loadBtn = document.getElementById("loadBtn");
const fileInput = document.getElementById("fileInput");

// -------------------- GAME VARIABLES --------------------
let TILE_SIZE = 32;
let WORLD_WIDTH, WORLD_HEIGHT;
let world = [];
let camera = { x:0, y:0, width:canvas.width, height:canvas.height };

// Player
let player = { x:100, y:100, width:28, height:32, velX:0, velY:0, speed:3, onGround:false };

// Inventory
let inventory = {1:99, 2:99, 3:99}; // dirt=1, grass=2, stone=3
let selectedBlock = 1;

// Input
let keys = {};
document.addEventListener("keydown", e => keys[e.key] = true);
document.addEventListener("keyup", e => keys[e.key] = false);

// Number keys switch block type
document.addEventListener("keydown", e => {
  if(e.key==="1") selectedBlock=1;
  if(e.key==="2") selectedBlock=2;
  if(e.key==="3") selectedBlock=3;
});

// -------------------- SEEDED RANDOM --------------------
function mulberry32(a){return function(){var t=a+=0x6D2B79F5;t=Math.imul(t^(t>>>15),t|1);t^=t+Math.imul(t^(t>>>7),t|61);return ((t^(t>>>14))>>>0)/4294967296;}}
let rand;

// -------------------- EVENT LISTENERS --------------------
startBtn.onclick = () => {
  WORLD_WIDTH = parseInt(mapWidthInput.value);
  WORLD_HEIGHT = parseInt(mapHeightInput.value);
  let seedVal = seedInput.value ? hashCode(seedInput.value) : Math.floor(Math.random()*1000000);
  rand = mulberry32(seedVal);

  // Initialize world array
  world = [];
  for(let y=0;y<WORLD_HEIGHT;y++) world[y] = new Array(WORLD_WIDTH).fill(0);

  menu.style.display="none";
  loadingScreen.style.display="flex";
  generateWorldStep(0);
};

loadBtn.onclick = () => fileInput.click();

fileInput.onchange = e => {
  const file = e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = ev => {
    const data = JSON.parse(ev.target.result);
    WORLD_WIDTH = data.world[0].length;
    WORLD_HEIGHT = data.world.length;
    world = data.world;
    player = data.player;
    inventory = data.inventory;
    menu.style.display="none";
    loadingScreen.style.display="none";
    update();
  };
  reader.readAsText(file);
};

// -------------------- HASH FUNCTION --------------------
function hashCode(str){
  let hash=0;
  for(let i=0;i<str.length;i++){
    hash=(hash<<5)-hash+str.charCodeAt(i);
    hash|=0;
  }
  return hash;
}

// -------------------- WORLD GENERATION --------------------
const BEDROCK_HEIGHT=2;
const SKY_HEIGHT=20;
const DIRT_DEPTH=3;

function generateWorldStep(col){
  if(col>=WORLD_WIDTH){
    loadingScreen.style.display="none";
    update(); // start game
    return;
  }

  // Smooth hill height
  let lastGround = SKY_HEIGHT + 12;
  if(col>0){
    let prevCol = col-1;
    for(let y=0;y<WORLD_HEIGHT;y++){
      if(world[y][prevCol]===2){ lastGround=y; break; }
    }
  }
  lastGround += Math.floor(rand()*3 - 1);
  if(lastGround<SKY_HEIGHT+10) lastGround=SKY_HEIGHT+10;
  if(lastGround>SKY_HEIGHT+15) lastGround=SKY_HEIGHT+15;

  for(let y=0;y<WORLD_HEIGHT;y++){
    if(y===lastGround) world[y][col]=2; // grass
    else if(y>lastGround && y<=lastGround+DIRT_DEPTH) world[y][col]=1; // dirt
    else if(y>lastGround+DIRT_DEPTH && y<WORLD_HEIGHT-BEDROCK_HEIGHT) world[y][col]=3; // stone
    else if(y>=WORLD_HEIGHT-BEDROCK_HEIGHT) world[y][col]=4; // bedrock
    else world[y][col]=0; // air
  }

  // Update progress bar
  loadingBar.style.width = ((col+1)/WORLD_WIDTH*100)+"%";

  requestAnimationFrame(()=>generateWorldStep(col+1));
}

// -------------------- SAVE GAME --------------------
function saveGame(){
  const saveData = {world:world, player:player, inventory:inventory};
  const blob = new Blob([JSON.stringify(saveData)], {type:"application/json"});
  const link = document.createElement("a");
  link.href=URL.createObjectURL(blob);
  link.download="save.json";
  link.click();
}

// -------------------- CLICK TO PLACE/REMOVE BLOCKS --------------------
canvas.addEventListener("click", e=>{
  const x = Math.floor((e.offsetX+camera.x)/TILE_SIZE);
  const y = Math.floor((e.offsetY+camera.y)/TILE_SIZE);
  if(y<SKY_HEIGHT || y>=WORLD_HEIGHT-BEDROCK_HEIGHT) return;
  if(world[y][x]===0 && inventory[selectedBlock]>0){ world[y][x]=selectedBlock; inventory[selectedBlock]--; }
  else if(world[y][x]>=1 && world[y][x]!==4){ inventory[world[y][x]]++; world[y][x]=0; }
});

// -------------------- CAMERA --------------------
function updateCamera(){
  camera.x = player.x + player.width/2 - camera.width/2;
  camera.y = player.y + player.height/2 - camera.height/2;
  if(camera.x<0) camera.x=0;
  if(camera.y<0) camera.y=0;
  if(camera.x+camera.width>WORLD_WIDTH*TILE_SIZE) camera.x=WORLD_WIDTH*TILE_SIZE-camera.width;
  if(camera.y+camera.height>WORLD_HEIGHT*TILE_SIZE) camera.y=WORLD_HEIGHT*TILE_SIZE-camera.height;
}

// -------------------- COLLISION --------------------
function checkCollisions(){
  const left=Math.floor(player.x/TILE_SIZE);
  const right=Math.floor((player.x+player.width)/TILE_SIZE);
  const top=Math.floor(player.y/TILE_SIZE);
  const bottom=Math.floor((player.y+player.height)/TILE_SIZE);

  // Vertical
  if(player.velY>0){
    if(world[bottom]?.[left]>=1||world[bottom]?.[right]>=1){
      player.y = bottom*TILE_SIZE - player.height;
      player.velY=0;
      player.onGround=true;
    }
  } else if(player.velY<0){
    if(world[top]?.[left]>=1||world[top]?.[right]>=1){
      player.y=(top+1)*TILE_SIZE;
      player.velY=0;
    }
  }
  // Horizontal
  if(player.velX<0){
    if(world[top]?.[left]>=1||world[bottom]?.[left]>=1){
      player.x=(left+1)*TILE_SIZE;
    }
  } else if(player.velX>0){
    if(world[top]?.[right]>=1||world[bottom]?.[right]>=1){
      player.x=right*TILE_SIZE - player.width;
    }
  }
}

// -------------------- GAME LOOP --------------------
function update(){
  player.velX=0;
  if(keys["a"]||keys["ArrowLeft"]) player.velX=-player.speed;
  if(keys["d"]||keys["ArrowRight"]) player.velX=player.speed;
  player.x += player.velX;

  player.velY += 0.5; // gravity
  player.y += player.velY;

  if((keys["w"]||keys["ArrowUp"]) && player.onGround){ player.velY=-10; player.onGround=false; }

  checkCollisions();
  updateCamera();
  draw();
  requestAnimationFrame(update);
}

// -------------------- DRAW --------------------
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const startCol=Math.floor(camera.x/TILE_SIZE);
  const endCol=Math.ceil((camera.x+camera.width)/TILE_SIZE);
  const startRow=Math.floor(camera.y/TILE_SIZE);
  const endRow=Math.ceil((camera.y+camera.height)/TILE_SIZE);

  for(let y=startRow;y<endRow;y++){
    for(let x=startCol;x<endCol;x++){
      const tile=world[y]?.[x];
      if(tile===undefined) continue;
      switch(tile){
        case 1: ctx.fillStyle="saddlebrown"; break;
        case 2: ctx.fillStyle="green"; break;
        case 3: ctx.fillStyle="gray"; break;
        case 4: ctx.fillStyle="black"; break; // bedrock
        default: ctx.fillStyle="#87CEEB";
      }
      ctx.fillRect(x*TILE_SIZE-camera.x,y*TILE_SIZE-camera.y,TILE_SIZE,TILE_SIZE);
      if(tile!==0){ ctx.strokeStyle="black"; ctx.strokeRect(x*TILE_SIZE-camera.x,y*TILE_SIZE-camera.y,TILE_SIZE,TILE_SIZE); }
    }
  }

  // Player
  ctx.fillStyle="red";
  ctx.fillRect(player.x-camera.x,player.y-camera.y,player.width,player.height);
}

</script>

<!-- SAVE BUTTON -->
<div style="position:absolute;top:10px;left:10px;color:white;z-index:50">
  <button onclick="saveGame()">Save Game</button>
</div>

</body>
</html>
