<!DOCTYPE html>
<html>
<head>
  <title>Vertical Sandbox</title>
  <style>
    canvas { background: #87CEEB; display: block; margin: 0 auto; }
  </style>
</head>
<body>
<canvas id="game" width="800" height="600"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const TILE_SIZE = 32;
const WORLD_WIDTH = 100;
const WORLD_HEIGHT = 256;
const BEDROCK_HEIGHT = 2;    // bottom indestructible layers
const SKY_HEIGHT = 20;       // top sky limit

// Camera
let camera = { x:0, y:0, width: canvas.width, height: canvas.height };

// Create world array
let world = [];
for (let y = 0; y < WORLD_HEIGHT; y++) {
  world[y] = [];
  for (let x = 0; x < WORLD_WIDTH; x++) {

    // Top sky
    if (y < SKY_HEIGHT) world[y][x] = 0;

    // Bottom bedrock
    else if (y >= WORLD_HEIGHT - BEDROCK_HEIGHT) world[y][x] = 4;

    // Procedural terrain
    else {
      // rolling hills
      const maxGround = 14;
      const minGround = 10;
      let groundHeight = SKY_HEIGHT + 10 + Math.floor(Math.random() * 5);
      if (y === groundHeight) world[y][x] = 2;        // grass
      else if (y > groundHeight && y < WORLD_HEIGHT - BEDROCK_HEIGHT) world[y][x] = 1; // dirt
      else world[y][x] = 0;                            // air
    }
  }
}

// Player
let player = {
  x: 100,
  y: 100,
  width: 28,
  height: 32,
  velX: 0,
  velY: 0,
  speed: 3,
  onGround: false
};

let keys = {};
document.addEventListener("keydown", e => keys[e.key] = true);
document.addEventListener("keyup", e => keys[e.key] = false);

// Mouse click to place/remove blocks
canvas.addEventListener("click", e => {
  const x = Math.floor((e.offsetX + camera.x)/TILE_SIZE);
  const y = Math.floor((e.offsetY + camera.y)/TILE_SIZE);

  if (y >= SKY_HEIGHT && y < WORLD_HEIGHT - BEDROCK_HEIGHT) {
    if (world[y][x] === 0) world[y][x] = 1; // place block
    else world[y][x] = 0;                    // remove block
  }
});

// Collision checking (4 sides)
function checkCollisions() {
  const left = Math.floor(player.x / TILE_SIZE);
  const right = Math.floor((player.x + player.width) / TILE_SIZE);
  const top = Math.floor(player.y / TILE_SIZE);
  const bottom = Math.floor((player.y + player.height) / TILE_SIZE);

  // Vertical collision
  if (player.velY > 0) { // falling
    if (world[bottom]?.[left] >= 1 || world[bottom]?.[right] >= 1) {
      player.y = bottom * TILE_SIZE - player.height;
      player.velY = 0;
      player.onGround = true;
    }
  } else if (player.velY < 0) { // jumping
    if (world[top]?.[left] >= 1 || world[top]?.[right] >= 1) {
      player.y = (top + 1) * TILE_SIZE;
      player.velY = 0;
    }
  }

  // Horizontal collision
  if (player.velX < 0) { // left
    if (world[top]?.[left] >= 1 || world[bottom]?.[left] >= 1) {
      player.x = (left + 1) * TILE_SIZE;
    }
  } else if (player.velX > 0) { // right
    if (world[top]?.[right] >= 1 || world[bottom]?.[right] >= 1) {
      player.x = right * TILE_SIZE - player.width;
    }
  }
}

// Camera follows player
function updateCamera() {
  camera.x = player.x + player.width/2 - camera.width/2;
  camera.y = player.y + player.height/2 - camera.height/2;

  // Clamp to world bounds
  if (camera.x < 0) camera.x = 0;
  if (camera.y < 0) camera.y = 0;
  if (camera.x + camera.width > WORLD_WIDTH*TILE_SIZE)
    camera.x = WORLD_WIDTH*TILE_SIZE - camera.width;
  if (camera.y + camera.height > WORLD_HEIGHT*TILE_SIZE)
    camera.y = WORLD_HEIGHT*TILE_SIZE - camera.height;
}

// Game loop
function update() {
  // Horizontal movement
  player.velX = 0;
  if (keys["a"] || keys["ArrowLeft"]) player.velX = -player.speed;
  if (keys["d"] || keys["ArrowRight"]) player.velX = player.speed;
  player.x += player.velX;

  // Gravity
  player.velY += 0.5;
  player.y += player.velY;

  // Jump
  if ((keys["w"] || keys["ArrowUp"]) && player.onGround) {
    player.velY = -10;
    player.onGround = false;
  }

  checkCollisions();
  updateCamera();
  draw();
  requestAnimationFrame(update);
}

// Draw world and player
function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const startCol = Math.floor(camera.x / TILE_SIZE);
  const endCol = Math.ceil((camera.x + camera.width) / TILE_SIZE);
  const startRow = Math.floor(camera.y / TILE_SIZE);
  const endRow = Math.ceil((camera.y + camera.height) / TILE_SIZE);

  for (let y = startRow; y < endRow; y++) {
    for (let x = startCol; x < endCol; x++) {
      const tile = world[y]?.[x];
      if (tile === undefined) continue;

      switch(tile) {
        case 1: ctx.fillStyle = "saddlebrown"; break; // dirt
        case 2: ctx.fillStyle = "green"; break;       // grass
        case 4: ctx.fillStyle = "gray"; break;        // bedrock
        default: ctx.fillStyle = "#87CEEB";           // air
      }

      ctx.fillRect(
        x*TILE_SIZE - camera.x,
        y*TILE_SIZE - camera.y,
        TILE_SIZE, TILE_SIZE
      );

      if (tile !== 0) {
        ctx.strokeStyle = "black";
        ctx.strokeRect(
          x*TILE_SIZE - camera.x,
          y*TILE_SIZE - camera.y,
          TILE_SIZE, TILE_SIZE
        );
      }
    }
  }

  // Draw player
  ctx.fillStyle = "red";
  ctx.fillRect(
    player.x - camera.x,
    player.y - camera.y,
    player.width,
    player.height
  );
}

update();
</script>
</body>
</html>
